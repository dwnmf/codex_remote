#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"
DEFAULT_HOME="${HOME}/.codex-remote"
if [[ -n "${CODEX_REMOTE_HOME:-}" ]]; then
  CODEX_REMOTE_HOME="$CODEX_REMOTE_HOME"
elif [[ -d "$REPO_ROOT/services/anchor" ]]; then
  CODEX_REMOTE_HOME="$REPO_ROOT"
elif [[ -d "$DEFAULT_HOME/services/anchor" ]]; then
  CODEX_REMOTE_HOME="$DEFAULT_HOME"
else
  CODEX_REMOTE_HOME="$DEFAULT_HOME"
fi
ANCHOR_DIR="$CODEX_REMOTE_HOME/services/anchor"
ENV_FILE="$CODEX_REMOTE_HOME/.env"
GLOBAL_CREDENTIALS_FILE="$DEFAULT_HOME/credentials.json"
LOCAL_CREDENTIALS_FILE="$CODEX_REMOTE_HOME/credentials.json"
if [[ -n "${CODEX_REMOTE_CREDENTIALS_FILE:-}" ]]; then
  CREDENTIALS_FILE="$CODEX_REMOTE_CREDENTIALS_FILE"
else
  CREDENTIALS_FILE="$GLOBAL_CREDENTIALS_FILE"
fi

# ── Colors ──────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

pass() { printf "  ${GREEN}✓${RESET} %s\n" "$1"; }
fail() { printf "  ${RED}✗${RESET} %s\n" "$1"; }
warn() { printf "  ${YELLOW}⚠${RESET} %s\n" "$1"; }
info() { printf "  %s\n" "$1"; }

default_env_content() {
  cat <<'EOF'
# Codex Remote Anchor Configuration (self-host)
# Run 'codex-remote self-host' to complete setup.
SELF_HOST_PROVIDER=
DENO_DEPLOY_PROJECT=
DENO_DEPLOY_TOKEN=
DENO_WEB_JWT_SECRET=
DENO_ANCHOR_JWT_SECRET=
CODEX_REMOTE_ANCHOR_JWT_SECRET=
ANCHOR_PORT=8788
ANCHOR_ORBIT_URL=
AUTH_URL=
AUTH_MODE=passkey
VAPID_PUBLIC_KEY=
ANCHOR_JWT_TTL_SEC=300
ANCHOR_APP_CWD=
D1_DATABASE_ID=
EOF
}

ensure_env_file() {
  if [[ -f "$ENV_FILE" ]]; then
    return 0
  fi

  mkdir -p "$CODEX_REMOTE_HOME"
  local example
  for example in "$CODEX_REMOTE_HOME/.env.example" "$REPO_ROOT/.env.example" "$SCRIPT_DIR/.env.example"; do
    if [[ -f "$example" ]]; then
      cp "$example" "$ENV_FILE"
      return 0
    fi
  done

  default_env_content > "$ENV_FILE"
}

can_run_wrangler() {
  command -v wrangler &>/dev/null || command -v bunx &>/dev/null || command -v bun &>/dev/null
}

can_run_deployctl() {
  command -v deployctl &>/dev/null || command -v deno &>/dev/null
}

run_deployctl() {
  if command -v deployctl &>/dev/null; then
    deployctl "$@"
    return $?
  fi
  if command -v deno &>/dev/null; then
    deno run -A jsr:@deno/deployctl "$@"
    return $?
  fi
  echo "Error: deployctl is unavailable (install deployctl or deno)."
  return 127
}

run_wrangler() {
  if command -v wrangler &>/dev/null; then
    wrangler "$@"
    return $?
  fi
  if command -v bunx &>/dev/null; then
    bunx --bun wrangler "$@"
    return $?
  fi
  if command -v bun &>/dev/null; then
    bun x wrangler "$@"
    return $?
  fi
  echo "Error: wrangler is unavailable (install wrangler or bun)."
  return 127
}

wrangler_tty() {
  if [[ -r /dev/tty ]]; then
    run_wrangler "$@" < /dev/tty
  else
    run_wrangler "$@"
  fi
}

deployctl_tty() {
  if [[ -r /dev/tty ]]; then
    run_deployctl "$@" < /dev/tty
  else
    run_deployctl "$@"
  fi
}

confirm_yes_default() {
  local prompt="$1"
  local answer=""
  if [[ ! -r /dev/tty ]]; then
    return 1
  fi
  printf "%s [Y/n] " "$prompt" > /dev/tty
  read -r answer < /dev/tty || return 1
  [[ -z "$answer" || "$answer" =~ ^[Yy] ]]
}

retry_cmd() {
  local attempts="$1" delay="$2" desc="$3"
  shift 3
  local i
  for ((i = 1; i <= attempts; i++)); do
    if "$@"; then
      return 0
    fi
    if ((i < attempts)); then
      warn "$desc failed (attempt $i/$attempts) — retrying in ${delay}s..."
      sleep "$delay"
    fi
  done
  return 1
}

update_database_id_toml() {
  local toml_path="$1"
  local db_id="$2"
  local tmp

  tmp="$(mktemp "${toml_path}.tmp.XXXXXX")" || return 1
  awk -v replacement="$db_id" '
    BEGIN { updated = 0 }
    /^database_id[[:space:]]*=[[:space:]]*"/ {
      print "database_id = \"" replacement "\""
      updated = 1
      next
    }
    { print }
    END { if (updated == 0) exit 1 }
  ' "$toml_path" > "$tmp" || {
    rm -f "$tmp"
    return 1
  }

  mv "$tmp" "$toml_path"
}

resolve_origin_branch() {
  local repo="$1"
  local remote_head
  remote_head=$(git -C "$repo" symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null || true)
  if [[ -n "$remote_head" ]]; then
    printf "%s" "${remote_head#origin/}"
    return
  fi
  printf "main"
}

# ── Commands ────────────────────────────────────

cmd_start() {
  if ! command -v bun &>/dev/null; then
    echo "Error: bun is not installed. Run 'codex-remote doctor' for details."
    exit 1
  fi

  ensure_env_file

  if [[ ! -f "$ANCHOR_DIR/src/index.ts" ]]; then
    echo "Error: Anchor service not found at $ANCHOR_DIR"
    exit 1
  fi

  mkdir -p "$(dirname "$CREDENTIALS_FILE")"
  if [[ "$CREDENTIALS_FILE" != "$LOCAL_CREDENTIALS_FILE" && ! -f "$CREDENTIALS_FILE" && -f "$LOCAL_CREDENTIALS_FILE" ]]; then
    cp "$LOCAL_CREDENTIALS_FILE" "$CREDENTIALS_FILE"
  fi

  CODEX_REMOTE_CREDENTIALS_FILE="$CREDENTIALS_FILE" exec bun --env-file "$ENV_FILE" "$ANCHOR_DIR/src/index.ts"
}

cmd_login() {
  if ! command -v bun &>/dev/null; then
    echo "Error: bun is not installed. Run 'codex-remote doctor' for details."
    exit 1
  fi

  ensure_env_file

  if [[ ! -f "$ANCHOR_DIR/src/index.ts" ]]; then
    echo "Error: Anchor service not found at $ANCHOR_DIR"
    exit 1
  fi

  mkdir -p "$(dirname "$CREDENTIALS_FILE")"
  if [[ "$CREDENTIALS_FILE" != "$LOCAL_CREDENTIALS_FILE" && ! -f "$CREDENTIALS_FILE" && -f "$LOCAL_CREDENTIALS_FILE" ]]; then
    cp "$LOCAL_CREDENTIALS_FILE" "$CREDENTIALS_FILE"
  fi

  CODEX_REMOTE_FORCE_LOGIN=1 CODEX_REMOTE_CREDENTIALS_FILE="$CREDENTIALS_FILE" exec bun --env-file "$ENV_FILE" "$ANCHOR_DIR/src/index.ts"
}

cmd_doctor() {
  echo ""
  printf "${BOLD}Codex Remote Doctor${RESET}\n"
  echo ""

  local has_error=0

  # Check CODEX_REMOTE_HOME
  if [[ -d "$CODEX_REMOTE_HOME" ]]; then
    pass "CODEX_REMOTE_HOME exists ($CODEX_REMOTE_HOME)"
  else
    fail "CODEX_REMOTE_HOME not found ($CODEX_REMOTE_HOME)"
    has_error=1
  fi

  # Check .env
  if [[ -f "$ENV_FILE" ]]; then
    pass ".env file exists"
  else
    fail ".env file not found at $ENV_FILE"
    has_error=1
  fi

  # Check Bun
  if command -v bun &>/dev/null; then
    pass "bun $(bun --version)"
  else
    fail "bun not installed"
    has_error=1
  fi

  # Check codex
  if command -v codex &>/dev/null; then
    pass "codex CLI installed"
  else
    fail "codex CLI not installed"
    has_error=1
  fi

  # Check anchor source
  if [[ -f "$ANCHOR_DIR/src/index.ts" ]]; then
    pass "Anchor service found"
  else
    fail "Anchor service not found at $ANCHOR_DIR"
    has_error=1
  fi

  # Check node_modules
  if [[ -d "$ANCHOR_DIR/node_modules" ]]; then
    pass "Anchor dependencies installed"
  else
    warn "Anchor dependencies not installed (run: cd $ANCHOR_DIR && bun install)"
  fi

  # Check env config and credentials
  if [[ -f "$ENV_FILE" ]]; then
    local orbit_url=""
    orbit_url=$(grep -E '^ANCHOR_ORBIT_URL=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)

    if [[ -n "$orbit_url" ]]; then
      pass "ANCHOR_ORBIT_URL configured"
      if [[ -f "$CREDENTIALS_FILE" ]]; then
        pass "Credentials file exists ($CREDENTIALS_FILE)"
      else
        warn "Not logged in. Run 'codex-remote login' or 'codex-remote start' to authenticate."
      fi
    else
      info "ANCHOR_ORBIT_URL not set (local-only mode)"
    fi
  fi

  # Check if anchor is already running
  local port
  port=$(grep -E '^ANCHOR_PORT=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || echo "8788")
  port="${port:-8788}"

  if curl -sf "http://localhost:$port/health" &>/dev/null; then
    local health
    health=$(curl -sf "http://localhost:$port/health" 2>/dev/null || echo "{}")
    pass "Anchor is running on port $port"
    local app_server
    app_server=$(echo "$health" | grep -o '"appServer":[^,}]*' | cut -d: -f2 || echo "unknown")
    local orbit_status
    orbit_status=$(echo "$health" | grep -o '"orbit":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
    info "  app-server: $app_server"
    info "  orbit: $orbit_status"
  else
    info "Anchor is not running on port $port"
  fi

  echo ""
  if [[ $has_error -eq 0 ]]; then
    printf "${GREEN}All checks passed.${RESET}\n"
  else
    printf "${RED}Some checks failed. Fix the issues above and try again.${RESET}\n"
  fi
  echo ""
}

cmd_config() {
  ensure_env_file

  local editor="${EDITOR:-nano}"
  exec "$editor" "$ENV_FILE"
}

cmd_update() {
  echo "Updating Codex Remote..."

  if [[ ! -d "$CODEX_REMOTE_HOME/.git" ]]; then
    echo "Error: $CODEX_REMOTE_HOME is not a git repository."
    exit 1
  fi

  local before after target_branch
  before=$(git -C "$CODEX_REMOTE_HOME" rev-parse --short HEAD 2>/dev/null || echo "unknown")

  if [[ -n "$(git -C "$CODEX_REMOTE_HOME" status --porcelain)" ]]; then
    warn "Local changes detected and will be overwritten."
  fi

  retry_cmd 3 3 "git fetch" git -C "$CODEX_REMOTE_HOME" fetch --prune origin \
    || { echo "Error: Failed to fetch updates from origin."; exit 1; }

  target_branch=$(resolve_origin_branch "$CODEX_REMOTE_HOME")
  if ! git -C "$CODEX_REMOTE_HOME" show-ref --verify --quiet "refs/remotes/origin/$target_branch"; then
    echo "Error: Remote branch origin/$target_branch not found."
    exit 1
  fi

  git -C "$CODEX_REMOTE_HOME" reset --hard --quiet "origin/$target_branch"
  git -C "$CODEX_REMOTE_HOME" clean -fd --quiet

  after=$(git -C "$CODEX_REMOTE_HOME" rev-parse --short HEAD 2>/dev/null || echo "unknown")

  if [[ "$before" == "$after" ]]; then
    echo "Already up to date ($after on origin/$target_branch)."
  else
    echo "Updated $before -> $after (origin/$target_branch)"
  fi

  # Re-apply D1 database ID to wrangler.toml files after reset
  if [[ -f "$ENV_FILE" ]]; then
    local db_id
    db_id=$(grep -E '^D1_DATABASE_ID=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
    if [[ -n "$db_id" ]]; then
      for toml_path in "$CODEX_REMOTE_HOME/wrangler.toml" "$CODEX_REMOTE_HOME/services/orbit/wrangler.toml"; do
        if [[ -f "$toml_path" ]]; then
          update_database_id_toml "$toml_path" "$db_id" \
            || { echo "Error: Failed to update database_id in $toml_path"; exit 1; }
        fi
      done
    fi
  fi

  echo "Installing dependencies..."
  retry_cmd 3 3 "Anchor dependency install" bash -c 'cd "$1" && bun install --silent' _ "$ANCHOR_DIR" \
    || { echo "Error: Failed to install Anchor dependencies."; exit 1; }

  # Redeploy web and orbit if self-hosted
  if [[ -f "$ENV_FILE" ]]; then
    local auth_url
    local vapid_public_key
    local provider
    auth_url=$(grep -E '^AUTH_URL=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
    vapid_public_key=$(grep -E '^VAPID_PUBLIC_KEY=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
    provider=$(grep -E '^SELF_HOST_PROVIDER=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
    provider="${provider:-cloudflare}"
    if [[ -n "$auth_url" ]]; then
      if [[ -z "$vapid_public_key" ]]; then
        echo "Error: VAPID_PUBLIC_KEY is missing in $ENV_FILE."
        echo "Run 'codex-remote self-host' to regenerate and persist push settings."
        exit 1
      fi

      echo "Rebuilding web..."
      retry_cmd 3 3 "Web dependency install" bash -c 'cd "$1" && bun install --silent' _ "$CODEX_REMOTE_HOME" \
        || { echo "Error: Failed to install web dependencies."; exit 1; }
      (cd "$CODEX_REMOTE_HOME" && AUTH_URL="$auth_url" VAPID_PUBLIC_KEY="$vapid_public_key" bun run build) \
        || { echo "Error: Web build failed."; exit 1; }

      if [[ "$provider" == "deno" ]]; then
        local project_name deno_web_secret deno_anchor_secret deno_deploy_token
        project_name=$(grep -E '^DENO_DEPLOY_PROJECT=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
        deno_web_secret=$(grep -E '^DENO_WEB_JWT_SECRET=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
        deno_anchor_secret=$(grep -E '^DENO_ANCHOR_JWT_SECRET=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
        if [[ -z "$deno_anchor_secret" ]]; then
          deno_anchor_secret=$(grep -E '^CODEX_REMOTE_ANCHOR_JWT_SECRET=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
        fi
        deno_deploy_token=$(grep -E '^DENO_DEPLOY_TOKEN=' "$ENV_FILE" 2>/dev/null | cut -d= -f2- || true)
        deno_deploy_token="${deno_deploy_token:-${DENO_DEPLOY_TOKEN:-}}"
        project_name="${project_name:-codex-remote}"

        if [[ -z "$deno_web_secret" || -z "$deno_anchor_secret" ]]; then
          echo "Error: Deno secrets are missing in $ENV_FILE."
          echo "Run 'codex-remote self-host --provider deno' to regenerate deployment config."
          exit 1
        fi
        if [[ -z "$deno_deploy_token" ]]; then
          echo "Error: DENO_DEPLOY_TOKEN is missing."
          echo "Set DENO_DEPLOY_TOKEN in $ENV_FILE or rerun 'codex-remote self-host --provider deno'."
          exit 1
        fi
        if ! can_run_deployctl; then
          echo "Error: deployctl is unavailable. Install deployctl or deno."
          exit 1
        fi

        echo "Deploying app (deno provider)..."
        (cd "$CODEX_REMOTE_HOME" && DENO_DEPLOY_TOKEN="$deno_deploy_token" deployctl_tty deploy \
          --project="$project_name" \
          --entrypoint=./services/orbit-deno/main.ts \
          --include=./services/orbit-deno/** \
          --include=./services/orbit/src/** \
          --include=./dist/** \
          --prod \
          --env="AUTH_MODE=passkey" \
          --env="CODEX_REMOTE_WEB_JWT_SECRET=$deno_web_secret" \
          --env="CODEX_REMOTE_ANCHOR_JWT_SECRET=$deno_anchor_secret" \
          --env="PASSKEY_ORIGIN=$auth_url" \
          --env="DEVICE_VERIFICATION_URL=$auth_url/device" \
          --env="CORS_ORIGINS=$auth_url") \
          || { echo "Error: Deno deploy failed."; exit 1; }
      else
        if ! can_run_wrangler; then
          echo "Error: wrangler is unavailable. Install wrangler or bun."
          exit 1
        fi

        echo "Deploying web..."
        (cd /tmp && CI=true wrangler_tty pages deploy "$CODEX_REMOTE_HOME/dist" --project-name codex-remote --branch main --commit-dirty=true) \
          || { echo "Error: Pages deploy failed."; exit 1; }

        echo "Deploying orbit..."
        retry_cmd 3 3 "Orbit dependency install" bash -c 'cd "$1" && bun install --silent' _ "$CODEX_REMOTE_HOME/services/orbit" \
          || { echo "Error: Failed to install Orbit dependencies."; exit 1; }
        (cd "$CODEX_REMOTE_HOME/services/orbit" && wrangler_tty deploy) \
          || { echo "Error: Orbit deploy failed."; exit 1; }
      fi
    fi
  fi

  echo "Done."
}

cmd_self_host() {
  local login_mode="ask"
  local provider="cloudflare"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --login) login_mode="always" ;;
      --no-login) login_mode="never" ;;
      --provider)
        shift
        [[ $# -gt 0 ]] || { echo "Error: --provider requires a value (cloudflare|deno)"; exit 1; }
        provider="$1"
        ;;
      --provider=*) provider="${1#--provider=}" ;;
      *)
        echo "Error: unknown option for self-host: $1"
        echo "Usage: codex-remote self-host [--provider cloudflare|deno] [--login|--no-login]"
        exit 1
        ;;
    esac
    shift
  done

  local script=""
  case "$provider" in
    cloudflare) script="$CODEX_REMOTE_HOME/bin/self-host.sh" ;;
    deno) script="$CODEX_REMOTE_HOME/bin/self-host-deno.sh" ;;
    *)
      echo "Error: unsupported provider '$provider'. Use cloudflare or deno."
      exit 1
      ;;
  esac

  if [[ ! -f "$script" ]]; then
    echo "Error: self-host wizard not found at $script"
    exit 1
  fi
  export CODEX_REMOTE_SELF_HOST_PROVIDER="$provider"
  export CODEX_REMOTE_SELF_HOST_LOGIN_MODE="$login_mode"
  # shellcheck source=/dev/null
  source "$script"

  local should_login=0
  case "$login_mode" in
    always) should_login=1 ;;
    never) should_login=0 ;;
    *)
      if confirm_yes_default "Run 'codex-remote login' now?"; then
        should_login=1
      fi
      ;;
  esac

  if [[ $should_login -eq 1 ]]; then
    echo "Launching login..."
    cmd_login
  else
    echo "Skipped login. Run 'codex-remote login' any time."
  fi
}

cmd_uninstall() {
  echo ""
  printf "${BOLD}Uninstall Codex Remote${RESET}\n"
  echo ""
  echo "This will remove:"
  echo "  $CODEX_REMOTE_HOME"
  echo "  PATH entries from shell config"
  echo ""
  printf "Are you sure? [y/N] "
  read -r confirm
  if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
    echo "Cancelled."
    exit 0
  fi

  # Remove CODEX_REMOTE_HOME
  if [[ -d "$CODEX_REMOTE_HOME" ]]; then
    rm -rf "$CODEX_REMOTE_HOME"
    echo "Removed $CODEX_REMOTE_HOME"
  fi

  # Clean PATH from shell rc files
  local rc_files=("$HOME/.zshrc" "$HOME/.bashrc" "$HOME/.bash_profile")
  for rc in "${rc_files[@]}"; do
    if [[ -f "$rc" ]] && grep -q 'codex-remote/bin' "$rc"; then
      awk '!/codex-remote\/bin/' "$rc" > "$rc.tmp" && mv "$rc.tmp" "$rc"
      echo "Cleaned $rc"
    fi
  done

  echo ""
  echo "Codex Remote has been uninstalled. Restart your terminal to apply PATH changes."
}

cmd_version() {
  if [[ -d "$CODEX_REMOTE_HOME/.git" ]]; then
    local tag
    tag=$(git -C "$CODEX_REMOTE_HOME" describe --tags --always 2>/dev/null || echo "dev")
    echo "codex-remote $tag"
  else
    echo "codex-remote dev"
  fi
}

cmd_help() {
  echo ""
  printf "${BOLD}Codex Remote${RESET} — local AI assistant bridge\n"
  echo ""
  echo "Usage: codex-remote <command>"
  echo ""
  echo "Commands:"
  echo "  start       Start the anchor service"
  echo "  login       Re-authenticate with the web app"
  echo "  doctor      Check prerequisites and configuration"
  echo "  config      Open .env in your editor"
  echo "  update      Pull latest code and reinstall dependencies"
  echo "  self-host   Run the self-host setup wizard"
  echo "              Options: --provider cloudflare|deno, --login, --no-login"
  echo "  uninstall   Remove Codex Remote from your system"
  echo "  version     Print version"
  echo "  help        Show this help"
  echo ""
}

# ── Main ────────────────────────────────────────

case "${1:-help}" in
  start)      cmd_start ;;
  login)      cmd_login ;;
  doctor)     cmd_doctor ;;
  config)     cmd_config ;;
  update)     cmd_update ;;
  self-host)  shift; cmd_self_host "$@" ;;
  uninstall)  cmd_uninstall ;;
  version)    cmd_version ;;
  help|--help|-h) cmd_help ;;
  *)
    echo "Unknown command: $1"
    cmd_help
    exit 1
    ;;
esac
